<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
 
 <title>~ Week Eight . 秋知 ~</title>
 <link href="/atom.xml" rel="self"/>
 <link href=""/>
 <updated>2014-09-29T00:24:49+08:00</updated>
 <id></id>
 <author>
   <name></name>
 </author>

 
 <entry>
   <title>phonegap调试总结</title>
   <link href="/2014/09/29/phonegap-debug.html"/>
   <updated>2014-09-29T12:23:00+08:00</updated>
   <id>/2014/09/29/phonegap-debug</id>
   <content type="html">&lt;h2 id=&quot;section&quot;&gt;写在前面&lt;/h2&gt;

&lt;p&gt;phonegap作为一个支持快速开发hybrid app的开发平台，同开发web app一样需要在无线环境下调试。但是不同的是，我们写的代码是运行在phonegap里的，给调试带来了一些难度，特别是当我们需要调用设备的原生功能时，例如定位，摄像头等。下面就自己在学习过程中对phonegap调试做个总结。&lt;/p&gt;

&lt;h2 id=&quot;phonegap-developer-app&quot;&gt;PhoneGap Developer App&lt;/h2&gt;

&lt;p&gt;从phonegap3.0开始，官方推出了 &lt;a href=&quot;http://app.phonegap.com/&quot;&gt;PhoneGap Developer App&lt;/a&gt; ，主要作用是在PC下运行一个命令就自动建立起一个http服务，在手机端装上mobile app后连接上PC端开启的http服务则可以让我们的代码实时反应在手机端。这样调试起来就方便了许多，不用再编译到手机上才能观察了。但是这样存在的问题是，当我们想要类似打开chrome developer tool那样调试页面的DOM元素样式时怎么办呢？&lt;/p&gt;

&lt;h2 id=&quot;weinre&quot;&gt;WEINRE&lt;/h2&gt;

&lt;p&gt;全称：web inspector remote，是目前最常用的远程web调试器之一。它可以让我们在PC端像在chrome developer tool下修改代码，实时在手机端观察。除了可以实时修改DOM样式外，还可以在控制台查看js对象等。&lt;/p&gt;

&lt;p&gt;优点：可在PC端修改css样式，实时在手机端查看；可以查看网络请求；可在控制台访问js对象
缺点：无法做网络资源代理，当需要对网络请求断点，修改请求或响应时无法满足需求；不能断点调试js&lt;/p&gt;

&lt;p&gt;具体的安装和使用这里就不介绍了，请自行google。&lt;/p&gt;

&lt;h2 id=&quot;charlesfiddler&quot;&gt;Charles/Fiddler&lt;/h2&gt;

&lt;p&gt;无线开发调试网络请求是最刚需，特别是需要模拟网速，断点请求，修改响应等时显得非常重要。phonegap开发更是如此，因为它不能像在PC端那样利用简便的chrome开发人员工具来调试。如果是在mac下开发强烈推荐Charles，功能齐全使用也简单，window下无疑是fiddler了。&lt;/p&gt;

&lt;p&gt;优点：使用Charles可以方便地模拟移动网速，代理本地文件，修改请求响应等，是移动开发网络调试的不二选择。&lt;/p&gt;

&lt;h2 id=&quot;gapdebug&quot;&gt;GapDebug&lt;/h2&gt;

&lt;p&gt;上面提到的还有一个很关键的问题没有解决：js断点调试，这个一直是无线端开发比较难搞的一点。对于普通的web app，例如在ios Safari下可开发调试模式在PC端的Safari下断点调试，还是很方便的。但是对于那些嵌入在web view里面的web就显得很无力了。&lt;/p&gt;

&lt;p&gt;GapDebug是专门针对phonegap或Cordova app的一款真机调试工具，也是刚推出不久的一款真机调试神器。&lt;/p&gt;

&lt;p&gt;优点：可断点调试js，真机调试；支持同时打开多个app调试；该有的web调试功能它都几乎具备了
缺点： 必须先编译安装到设备上才能连接到PC进行调试，所以如果不是非常必要还是不要用这种方式来调试了，很耗时间。&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;总结&lt;/h2&gt;

&lt;p&gt;总结起来，phonegap开发调试的步骤大概如下：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;通过&lt;code&gt;console.log &amp;amp; alert&lt;/code&gt;来初步调试&lt;/li&gt;
  &lt;li&gt;如果不涉及调用设备原生api，先注释掉引用的cordova.js并从项目目录创建软连接到本地服务器根目录在本地服务器上浏览调试&lt;/li&gt;
  &lt;li&gt;需要在真机上观察调试时，使用weinre来真机调试css样式&lt;/li&gt;
  &lt;li&gt;需要调试网络请求时，打开charles来调试网络请求&lt;/li&gt;
  &lt;li&gt;调用到了设备原生API，并迫不得已时先编译安装app到手机上再使用gapdebug来真机断点调试&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;以上就是phonegap开发调试的大概步骤，可以开始布置工作区的时候就一并把这些工具都开启了，需要时再查看使用。&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>自动构建css sprite</title>
   <link href="/2014/08/28/%E8%87%AA%E5%8A%A8%E6%9E%84%E5%BB%BAcss-sprite.html"/>
   <updated>2014-08-28T00:00:00+08:00</updated>
   <id>/2014/08/28/自动构建css-sprite</id>
   <content type="html">&lt;h2 id=&quot;section&quot;&gt;背景&lt;/h2&gt;

&lt;p&gt;css sprite是我们前端开发再熟悉不过的网页图片处理方式了，这里也不再重复其优势。但是在使用css sprite总会遇到很多问题，例如头痛的拼图定位，css样式微调等，特别是面临项目开发时间紧张，UI设计图总要分期提供，多人协同开发又要考虑是否将所有小图标合到同一个拼图里，是否需要将拼图分组，考虑如何排版才够优雅有序等等。我们总不能每次UI设计给了一个小图又打开PS粘贴图层慢慢地在调整，再导出，这样的工作太重复繁琐了。&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;需求&lt;/h2&gt;

&lt;p&gt;是否有一个工具能让我们在开发阶段像往常一样不用考虑拼图，非常自然地编写css，单独地引用小图，能够应对随时可能改变的UI设计给的小图，同时又能够人性化地确定小图之间的间距，排版，能兼容IE6这个不支持透明背景图的问题最好了，还有，要是能用less来编写那就完美了。答案是有的，网上现在也有各种的css sprite的构建工具来处理这些事情，下面我们就来看看这些工具的优劣，是否能满足我们的需求。&lt;/p&gt;

&lt;h2 id=&quot;css-sprite&quot;&gt;css sprite构建工具介绍&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://www.npmjs.org/package/css-sprite&quot;&gt;&lt;strong&gt;css-sprite&lt;/strong&gt;&lt;/a&gt;相对来说是一个很强大的小图标合并工具了，支持 less , sass , stylus ,还有 gulp 和 grunt 插件，简单的用法如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//use with gulp
var gulp = require(&#39;gulp&#39;);
var gulpif = require(&#39;gulp-if&#39;);
var sprite = require(&#39;css-sprite&#39;).stream;
// generate sprite.png and _sprite.scss
gulp.task(&#39;sprites&#39;, function () {
  return gulp.src(&#39;./src/img/*.png&#39;)
    .pipe(sprite({
      name: &#39;sprite.png&#39;,
      style: &#39;sprite.less&#39;,
      cssPath: &#39;./img&#39;,
      processor: &#39;less&#39;
    }))
    .pipe(gulpif(&#39;*.png&#39;, gulp.dest(&#39;./dist/img/&#39;), gulp.dest(&#39;./dist/less/&#39;)))
});

//生成合拼后的图片和对应的less文件sprite.less后，再在我们自己的less文件 @import 进去使用
@import &#39;sprite&#39;; // the generated style file (sprite.less)
// camera icon (camera.png in src directory)
.icon-camera {
  .sprite(@camera);
}

// cart icon (cart.png in src directory)
.icon-cart {
  .sprite(@cart);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;通过上面，我们对css-sprite可以得出以下结论：
优点 ： 功能强大，支持less,sass,stylus，还有gulp/grunt插件，支持 retina屏
缺点 ： 需要我们手动引入生成后的css/less/sass文件，再在相应的地方引用得到的变量的样式，不够灵活，开发阶段编写css代码不自然，不支持png8（ie6不适用）；依赖&lt;a href=&quot;https://github.com/learnboost/node-canvas&quot;&gt;node-canvas&lt;/a&gt;和&lt;a href=&quot;http://cairographics.org/&quot;&gt;Cairo&lt;/a&gt;来处理图片，这里面的依赖安装很麻烦，稍不留神就安装出错。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://csssprites.org/&quot;&gt;&lt;strong&gt;smart sprite&lt;/strong&gt;&lt;/a&gt;应该是发展了比较久的一个css sprite构建工具了，该有的功能几乎都有了，最近还增加支持了png8。简单实用例子：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/** sprite: mysprite; sprite-image: url(&#39;../img/mysprite.png&#39;); sprite-layout: vertical */
#web {
width: 17px; height: 17px;
background-repeat: no-repeat;
background-image: url(../img/web.gif); /** sprite-ref: mysprite; */
}

#logo {
width: 50px; height: 50px;
background-repeat: no-repeat;
background-position: top right;
background-image: url(../img/logo.png); /** sprite-ref: mysprite; sprite-alignment: right */
}

#main-box {
background-repeat: repeat-x;
background-position: 5px left;
background-image: url(../img/top-frame.gif); /** sprite-ref: mysprite; sprite-alignment: repeat; sprite-margin-top: 5px */
}

//将生成如下css代码
#web { 
width: 17px; height: 17px; 
background-repeat: no-repeat; 
background-image: url(&#39;../img/mysprite.png&#39;);
background-position: left -0px;
} 

#logo { 
width: 50px; height: 50px; 
background-repeat: no-repeat; 
background-position: top right; 
background-image: url(&#39;../img/mysprite.png&#39;);
background-position: right -17px;
} 

#main-box { 
background-repeat: repeat-x; 
background-position: 5px left; 
background-image: url(&#39;../img/mysprite.png&#39;);
background-position: left -64px;
} 优点： 支持png8，支持自定义分组，排版，repeat方式，自定义图片间距等,会修改原css文件得到处理后的css文件，开发阶段编写代码不用手动引用生成的css文件了。 缺点： 依赖Java环境，意味着要装JDK，对前端童鞋来说可能不是那么好玩；需要在每张图片后面写上注释语法使得smart sprite能够识别，并根据语法生成图片，样式；
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&quot;http://alloyteam.github.io/gopng/&quot;&gt;&lt;strong&gt;gopng&lt;/strong&gt;&lt;/a&gt;是腾讯alloyteam开发的一个在线的css sprite生成工具，用canvas来实现，需要手动拖动图片到画布，再生成图片和样式导出，虽省去用PS来调整但是感觉还是太繁琐了。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://joycss.org/&quot;&gt;&lt;strong&gt;joycss&lt;/strong&gt;&lt;/a&gt;是我们大阿里@翰文童鞋开发的一个神器，使用简单，功能强大。支持x/y方向图片平铺，自定义位置间距，png8，支持使用图片url参数来定义图片生成规则，在淘宝内部使用还可以使用upload接口直接把图片传到tps上面省去了自己上传的功夫。总的来说，恰好满足上面所提到的各种需求，也是我目前为止发现的使用最简单，最符合实际需求的一个自动拼图工具了。具体的使用方法可以到&lt;a href=&quot;https://github.com/shepherdwind/joycss&quot;&gt;joycss&lt;/a&gt;上面看。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.npmjs.org/package/gulp-joycss&quot;&gt;&lt;strong&gt;gulp-joycss&lt;/strong&gt;&lt;/a&gt;是我在做&lt;a href=&quot;https://github.com/kissyteam/editor-plugins&quot;&gt;kissy editor-plugins&lt;/a&gt;构建的时候使用joycss写的一个插件，当时joycss不支持引用png8，生成的css样式也有部分丢失等问题，也只有grunt-joycss插件而已。gulp-joycss的简单使用如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var gulpJoycss = require(&#39;gulp-joycss);
gulp.src(&#39;assets/*.less&#39;)
.pipe(gulpJoycss({
    &#39;editor.less&#39; : {  //对应文件的相关配置，每一个文件都必须配置
        imgPath : &#39;build/assets&#39;,   //生成后的图片位置
        dest : &#39;build/assets/editor.css&#39;,  //生成后的文件路径
        prefixUrl : &#39;/editor-plugins/&#39; + packageJson.version + &#39;/assets&#39;   //压缩后的css(用于发布)，引用生成的sprite图的地址前缀（图片在服务器上面的相应位置），而debug文件则不加前缀，用于调试
    },
    &#39;iframe.less&#39; : {  //如果当前文件不需要生成图片，仅是转化less，则不需要配置imgPath
        dest : &#39;build/assets/iframe.css&#39;
    }
}))
.pipe(gulp.dest(&#39;build/assets&#39;));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;总结：自动拼图工具真的很多，开始的时候自己在寻找符合需求的工具花了不少时间，每个工具用起来了才发现这里不符合那里又有问题，总找不到一个完全符合需求的工具。其实想想，与其花那么时间去尝试别人写的工具是否符合自己的需求还不如选一个接近的工具动手修改成符合自己需求的，这样或许收获更大，效率更高！最后，真心感谢@翰文的支持！&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>如何编写Gulp插件&amp;gulp-kmd</title>
   <link href="/2014/08/20/writing-gulp-plugin.html"/>
   <updated>2014-08-20T00:00:00+08:00</updated>
   <id>/2014/08/20/writing-gulp-plugin</id>
   <content type="html">&lt;h2 id=&quot;gulp&quot;&gt;gulp简单介绍&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;gulp&lt;/code&gt;正如官网所说的那样是一个&lt;code&gt;The streaming build system&lt;/code&gt;，一个充分利用了&lt;code&gt;Node.js Streams API&lt;/code&gt;的一个构建任务管理工具，更简单清爽的插件使用习惯。ATA上&lt;em&gt;@剑平&lt;/em&gt;也介绍过&lt;code&gt;gulp&lt;/code&gt;的简单用法(&lt;a href=&quot;http://www.atatech.org/articles/13458&quot;&gt;传送门&lt;/a&gt;)&lt;/p&gt;

&lt;h2 id=&quot;grunt-vs-gulp&quot;&gt;grunt vs gulp&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;grunt&lt;/code&gt;是目前最流行的前端构建工具了，拥有强大的社区，丰富多样的插件。个人觉得&lt;code&gt;grunt&lt;/code&gt;与&lt;code&gt;gulp&lt;/code&gt;两者无所谓&lt;em&gt;好&lt;/em&gt;与&lt;em&gt;坏&lt;/em&gt;，各自都有自己的特点和缺点，如何选择其实更加偏向个人喜欢什么样的编码风格。关于两者的区别分析详情有兴趣的可以看下&lt;a href=&quot;&quot;&gt;这篇文章&lt;/a&gt;，下面主要做一下两者区别的总结：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;grunt&lt;/code&gt;拥有强大的社区，&lt;code&gt;gulp&lt;/code&gt;发展在前者之后，社区相对差一些&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;grunt&lt;/code&gt;拥有非常多的插件，&lt;code&gt;gulp&lt;/code&gt;插件覆盖度没那么广，但是质量相对高一下，&lt;a href=&quot;http://gulpjs.com/plugins/&quot;&gt;常用的插件&lt;/a&gt;也差不多都有&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;grunt&lt;/code&gt;相对有点配置‘优先’的感觉，插件配置较多，而&lt;code&gt;gulp&lt;/code&gt;更好地诠释了&lt;a href=&quot;&quot;&gt;&lt;strong&gt;code over configuration&lt;/strong&gt;&lt;/a&gt;，插件使用清爽优雅&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;grunt&lt;/code&gt;相对频繁使用&lt;code&gt;IO&lt;/code&gt;，而&lt;code&gt;gulp&lt;/code&gt;利用&lt;code&gt;stream&lt;/code&gt;把一切都用&lt;code&gt;pipe&lt;/code&gt;(管道)优雅方便地串连起来了。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;gulp-1&quot;&gt;gulp简单插件编写基础&lt;/h2&gt;

&lt;p&gt;关于&lt;code&gt;gulp&lt;/code&gt;插件编写，&lt;em&gt;@剑平&lt;/em&gt;也有写过一篇相似的文章&lt;a href=&quot;http://www.atatech.org/articles/14002&quot;&gt;Gulp.js深入讲解&lt;/a&gt;介绍。&lt;code&gt;gulp&lt;/code&gt;插件编写最重要的是理解&lt;code&gt;Node.js&lt;/code&gt;中的三种&lt;code&gt;stream&lt;/code&gt; : &lt;code&gt;readable streams&lt;/code&gt;,&lt;code&gt;writeable streams&lt;/code&gt;,&lt;code&gt;transform stream&lt;/code&gt;，以及最常用的&lt;code&gt;through2&lt;/code&gt;,&lt;code&gt;gulp-util&lt;/code&gt;模块，还有&lt;code&gt;gulp&lt;/code&gt;提供的几个API：&lt;code&gt;gulp.src&lt;/code&gt;,&lt;code&gt;gulp.dest&lt;/code&gt;。下面先对这些需要使用的基本模块，API做个介绍，最后通过一个简单实例来讲述一个&lt;code&gt;gulp&lt;/code&gt;插件如何编写。&lt;/p&gt;

&lt;p&gt;在&lt;code&gt;node.js&lt;/code&gt;里面有四种&lt;code&gt;stream&lt;/code&gt; : &lt;code&gt;readable streams&lt;/code&gt;(只读的流),&lt;code&gt;writeable streams&lt;/code&gt;（只写的流）,&lt;code&gt;transform stream&lt;/code&gt;（读/写流）,&lt;code&gt;duplex streams&lt;/code&gt;（循环流，这里不讨论）。&lt;/p&gt;

&lt;p&gt;在&lt;code&gt;node.js&lt;/code&gt;里面最简单的写法就是：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var fs = require(&#39;fs&#39;);
fs.createReadStream(&#39;xx.js&#39;).pipe(fs.createWriteStream(&#39;yy.js&#39;))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;意指将一个文件以&lt;em&gt;只读流&lt;/em&gt;的方式读取内容再通过&lt;code&gt;pipe&lt;/code&gt;（管道）导入一个&lt;em&gt;只写流&lt;/em&gt;写进文件。&lt;/p&gt;

&lt;p&gt;那么，如果我们需要在&lt;code&gt;只读流&lt;/code&gt;和&lt;code&gt;只写流&lt;/code&gt;间做一些修改再通过&lt;code&gt;pipe&lt;/code&gt;写到最终文件里面应该怎么做呢？这也就需要使用&lt;code&gt;读写流&lt;/code&gt;来充当一个类似&lt;em&gt;中转站&lt;/em&gt;效果了，而在&lt;code&gt;gulp&lt;/code&gt;插件编写中，最常用的就是使用&lt;code&gt;through2&lt;/code&gt;这个模块来替代&lt;code&gt;node.js&lt;/code&gt;原生的&lt;code&gt;transform stream&lt;/code&gt;了。（注：gulp官网示例用的就是这个模块，&lt;a href=&quot;http://www.atatech.org/articles/14002&quot;&gt;Gulp.js深入讲解&lt;/a&gt;这篇文章介绍的&lt;code&gt;gulp-clean&lt;/code&gt;用的是&lt;code&gt;event-stream&lt;/code&gt;）。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/rvagg/through2&quot;&gt;through2&lt;/a&gt;其实就是对&lt;code&gt;transform stream&lt;/code&gt;做了一层简单封装。在这里有必要说一下 through2() 和 through2.obj() 的区别，用法上面其实就是差了一个配置  through2({ objectMode: true }  == through2.obj()，那么不禁会问这个配置的意义是什么了，根据&lt;a href=&quot;http://nodejs.org/documentation/api/&quot;&gt;node.js Object Mode API&lt;/a&gt;解释，个人理解 through2.obj 能让我们在函数transformFunction里面对一个一个文件进行处理，而不只是片段，所以gulp插件中几乎都是使用through.obj这个函数的（这点不知是否理解有误，清楚的朋友希望能告诉我一下）&lt;/p&gt;

&lt;p&gt;&lt;code&gt;gulp.src&lt;/code&gt;其实就是用&lt;a href=&quot;https://github.com/isaacs/node-glob&quot;&gt;node-glob&lt;/a&gt;去读取相应文件并创建一个简单封装后的流能通过&lt;code&gt;pipe&lt;/code&gt;传给后面处理&lt;/p&gt;

&lt;h2 id=&quot;gulp--gulp-kmd&quot;&gt;gulp插件编写示例 ~ gulp-kmd&lt;/h2&gt;

&lt;p&gt;一个简单的gulp插件需要多少行代码？我的回答是只要&lt;strong&gt;24&lt;/strong&gt;行代码，对的，就是24行代码。今天在做&lt;code&gt;kissy editor-plugin&lt;/code&gt;的构建的时候，用到&lt;em&gt;@杰少&lt;/em&gt;写的kmd和gulp-kmc这两个工具，但是苦于没有gulp-kmd，默认的kmd模块只能在命令行下使用，不符合简化gulpfile.js的原则。于是乎看了下kmd源码提供的接口，找到&lt;code&gt;kmd.kissy2cmd.parse&lt;/code&gt;这个接口就开始做一个极简单的gulp插件了，以后喜欢使用gulp的童鞋也可以免去那二十几行代码写在gulpfile.js里面了。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.npmjs.org/package/gulp-kmd&quot;&gt;gulp-kmd传送门&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;代码比较少，直接贴代码了，解释写在代码注释中：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var kmd = require(&#39;kmd&#39;),
through2 = require(&#39;through2&#39;),
gutil = require(&#39;gulp-util&#39;),
PluginError = gutil.PluginError;  //官网强烈推荐标准的错误处理模块
var kissy2cmd = kmd.kissy2cmd;
const PLUGIN_NAME = &#39;gulp-kmd&#39;;
function confirmCmd(){
	var stream = through2.obj(function(file, enc, callback){
		//这里的file就是一个对象，有三个属性 contents（Buffer，文件内容）、base（路径）、path（路径）
		//enc指编码
		if(file.isNull()){  //如果文件为空则不处理
			return callback();
		}
		if(file.isStream()){
			this.emit(&#39;error&#39;, new PluginError(PLUGIN_NAME, &#39;Streams are 				not supported!&#39;));  //规范的报错处理
  			return cb();
		}
		var fileInCmd = kissy2cmd.parse(file.contents.toString(),				{ fromString : true });
		file.contents = new Buffer(fileInCmd);
	 	this.push(file);  //把内容放到流中使得下一个任务可以处理
		callback();  //一定要调用callback告诉这个文件处理完了
	});
	return stream;
}
module.exports = confirmCmd;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;此外，说明一下，如果直接用fs.createReadStream会是怎样呢？如下代码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var fs = require(&#39;fs&#39;),
through = require(&#39;through2&#39;);
fs.createReadStream(&#39;test.txt&#39;)
	.pipe(through.obj(function(file, enc, cb){
		//这样拿到的file纯粹是一个文件的Buffer，和gulp.src拿到的不一样，也是gulp.src是对stream做了一个简单封装的表现
		debugger;
	}))
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;section&quot;&gt;总结&lt;/h2&gt;

&lt;p&gt;编写一个gulp插件还是比较简单的，重要的是先要把gulp的常用几个API熟悉，以及对stream的理解，还有就是多看别人的源码和多动手debug。要获取更多的信息请移步至&lt;a href=&quot;https://github.com/gulpjs/gulp/blob/master/docs/writing-a-plugin/README.md&quot;&gt;gulp官网&lt;/a&gt;看吧。&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>模块规范</title>
   <link href="/2014/08/18/module.html"/>
   <updated>2014-08-18T00:00:00+08:00</updated>
   <id>/2014/08/18/module</id>
   <content type="html">&lt;p&gt;&lt;a href=&quot;http://www.zhihu.com/question/20351507&quot;&gt;知乎玉伯回答&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// CMD
define(function(require, exports, module) {
var a = require(&#39;./a&#39;)
a.doSomething()
// 此处略去 100 行
var b = require(&#39;./b&#39;) // 依赖可以就近书写
b.doSomething()
// ... 
})

// AMD 默认推荐的是
define([&#39;./a&#39;, &#39;./b&#39;], function(a, b) { // 依赖必须一开始就写好
a.doSomething()
// 此处略去 100 行
b.doSomething()
...
}) 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;kmd -&amp;gt; kmc&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Welcome to Jekyll!</title>
   <link href="/2014/08/17/welcome-to-jekyll.html"/>
   <updated>2014-08-17T05:44:07+08:00</updated>
   <id>/2014/08/17/welcome-to-jekyll</id>
   <content type="html">&lt;p&gt;You’ll find this post in your &lt;code&gt;_posts&lt;/code&gt; directory. Go ahead and edit it and re-build the site to see your changes. You can rebuild the site in many different ways, but the most common way is to run &lt;code&gt;jekyll serve --watch&lt;/code&gt;, which launches a web server and auto-regenerates your site when a file is updated.&lt;/p&gt;

&lt;p&gt;To add new posts, simply add a file in the &lt;code&gt;_posts&lt;/code&gt; directory that follows the convention &lt;code&gt;YYYY-MM-DD-name-of-post.ext&lt;/code&gt; and includes the necessary front matter. Take a look at the source for this post to get an idea about how it works.&lt;/p&gt;

&lt;p&gt;Jekyll also offers powerful support for code snippets:&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-ruby&quot; data-lang=&quot;ruby&quot;&gt;&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;print_hi&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;nb&quot;&gt;puts&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&amp;quot;Hi, &lt;/span&gt;&lt;span class=&quot;si&quot;&gt;#{&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&amp;quot;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;print_hi&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;&amp;#39;Tom&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;#=&amp;gt; prints &amp;#39;Hi, Tom&amp;#39; to STDOUT.&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Check out the &lt;a href=&quot;http://jekyllrb.com&quot;&gt;Jekyll docs&lt;/a&gt; for more info on how to get the most out of Jekyll. File all bugs/feature requests at &lt;a href=&quot;https://github.com/jekyll/jekyll&quot;&gt;Jekyll’s GitHub repo&lt;/a&gt;. If you have questions, you can ask them on &lt;a href=&quot;https://github.com/jekyll/jekyll-help&quot;&gt;Jekyll’s dedicated Help repository&lt;/a&gt;.&lt;/p&gt;

</content>
 </entry>
 
 <entry>
   <title>My First Post on My Github Pages</title>
   <link href="/2014/08/17/my-first-post.html"/>
   <updated>2014-08-17T00:00:00+08:00</updated>
   <id>/2014/08/17/my-first-post</id>
   <content type="html">&lt;h1 id=&quot;section&quot;&gt;第一篇文章&lt;/h1&gt;

&lt;h2 id=&quot;learn-jekyll&quot;&gt;Learn Jekyll&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;var test = require(&#39;node&#39;);
alert(&#39;I just test&#39;);
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;day-day-up&quot;&gt;Day Day Up&lt;/h2&gt;

&lt;p&gt;好好学习，天天向上&lt;/p&gt;
</content>
 </entry>
 
 
</feed>
