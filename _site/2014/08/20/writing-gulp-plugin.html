<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en-us">
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <meta name="author" content="" />
    
    <title>如何编写Gulp插件&gulp-kmd</title>
    
    <link rel="shortcut icon" href="/favicon.ico">
    <link href="/atom.xml" rel="alternate" title="~ Week Eight . 秋知 ~" type="application/atom+xml" />
    <link rel="stylesheet" href="/media/css/style.css">
    <link rel="stylesheet" href="/media/css/github.css">
    <link rel="stylesheet" href="/media/css/fontawesome.css">
    <script src="/media/js/jquery-1.7.1.min.js" type="text/javascript" charset="utf-8"></script> 
    <script type="text/javascript" src="/media/js/highlight.pack.js"></script>
    <script type="text/javascript">
      hljs.initHighlightingOnLoad();
    </script>
  </head>
  <body>
      <div id="main" role="main">
        <header>
          <div id="header">
            <h1><a title="~ Week Eight . 秋知 ~" class="" href="/">~ Week Eight . 秋知 ~</a></h1>
          </div>
          <nav>
            
            <span><a title="Archive" href="/archive.html"><i class="fa fa-list-ul"></i></a></span>
            
            <span><a title="Tags" href="/tags.html"><i class="fa fa-tags"></i></a></span>
            
            <span><a title="About" href="/about.html"><i class="fa fa-user"></i></a></span>
            
            <span><a title="Subscribe" href="/atom.xml"><i class="fa fa-rss"></i></a></span>
            
          </nav>
        </header>
        <div id="content">
        <article>
  <section class="title">
    <h2>如何编写Gulp插件&gulp-kmd </h2>
  </section>
  <section class="meta">
  <span class="time">
    <time datetime="2014-08-20">2014-08-20</time>
  </span>
  
  <span class="tags">
    
    <a href="/tags.html#gulp nodejs javascript" title="gulp nodejs javascript">#gulp nodejs javascript</a>
    
  </span>
  
  </section>
  <section class="post">
  <h2 id="gulp">gulp简单介绍</h2>

<p><code>gulp</code>正如官网所说的那样是一个<code>The streaming build system</code>，一个充分利用了<code>Node.js Streams API</code>的一个构建任务管理工具，更简单清爽的插件使用习惯。ATA上<em>@剑平</em>也介绍过<code>gulp</code>的简单用法(<a href="http://www.atatech.org/articles/13458">传送门</a>)</p>

<h2 id="grunt-vs-gulp">grunt vs gulp</h2>

<p><code>grunt</code>是目前最流行的前端构建工具了，拥有强大的社区，丰富多样的插件。个人觉得<code>grunt</code>与<code>gulp</code>两者无所谓<em>好</em>与<em>坏</em>，各自都有自己的特点和缺点，如何选择其实更加偏向个人喜欢什么样的编码风格。关于两者的区别分析详情有兴趣的可以看下<a href="">这篇文章</a>，下面主要做一下两者区别的总结：</p>

<ul>
  <li><code>grunt</code>拥有强大的社区，<code>gulp</code>发展在前者之后，社区相对差一些</li>
  <li><code>grunt</code>拥有非常多的插件，<code>gulp</code>插件覆盖度没那么广，但是质量相对高一下，<a href="http://gulpjs.com/plugins/">常用的插件</a>也差不多都有</li>
  <li><code>grunt</code>相对有点配置‘优先’的感觉，插件配置较多，而<code>gulp</code>更好地诠释了<a href=""><strong>code over configuration</strong></a>，插件使用清爽优雅</li>
  <li><code>grunt</code>相对频繁使用<code>IO</code>，而<code>gulp</code>利用<code>stream</code>把一切都用<code>pipe</code>(管道)优雅方便地串连起来了。</li>
</ul>

<h2 id="gulp-1">gulp简单插件编写基础</h2>

<p>关于<code>gulp</code>插件编写，<em>@剑平</em>也有写过一篇相似的文章<a href="http://www.atatech.org/articles/14002">Gulp.js深入讲解</a>介绍。<code>gulp</code>插件编写最重要的是理解<code>Node.js</code>中的三种<code>stream</code> : <code>readable streams</code>,<code>writeable streams</code>,<code>transform stream</code>，以及最常用的<code>through2</code>,<code>gulp-util</code>模块，还有<code>gulp</code>提供的几个API：<code>gulp.src</code>,<code>gulp.dest</code>。下面先对这些需要使用的基本模块，API做个介绍，最后通过一个简单实例来讲述一个<code>gulp</code>插件如何编写。</p>

<p>在<code>node.js</code>里面有四种<code>stream</code> : <code>readable streams</code>(只读的流),<code>writeable streams</code>（只写的流）,<code>transform stream</code>（读/写流）,<code>duplex streams</code>（循环流，这里不讨论）。</p>

<p>在<code>node.js</code>里面最简单的写法就是：</p>

<pre><code>var fs = require('fs');
fs.createReadStream('xx.js').pipe(fs.createWriteStream('yy.js'))
</code></pre>

<p>意指将一个文件以<em>只读流</em>的方式读取内容再通过<code>pipe</code>（管道）导入一个<em>只写流</em>写进文件。</p>

<p>那么，如果我们需要在<code>只读流</code>和<code>只写流</code>间做一些修改再通过<code>pipe</code>写到最终文件里面应该怎么做呢？这也就需要使用<code>读写流</code>来充当一个类似<em>中转站</em>效果了，而在<code>gulp</code>插件编写中，最常用的就是使用<code>through2</code>这个模块来替代<code>node.js</code>原生的<code>transform stream</code>了。（注：gulp官网示例用的就是这个模块，<a href="http://www.atatech.org/articles/14002">Gulp.js深入讲解</a>这篇文章介绍的<code>gulp-clean</code>用的是<code>event-stream</code>）。</p>

<p><a href="https://github.com/rvagg/through2">through2</a>其实就是对<code>transform stream</code>做了一层简单封装。在这里有必要说一下 through2() 和 through2.obj() 的区别，用法上面其实就是差了一个配置  through2({ objectMode: true }  == through2.obj()，那么不禁会问这个配置的意义是什么了，根据<a href="http://nodejs.org/documentation/api/">node.js Object Mode API</a>解释，个人理解 through2.obj 能让我们在函数transformFunction里面对一个一个文件进行处理，而不只是片段，所以gulp插件中几乎都是使用through.obj这个函数的（这点不知是否理解有误，清楚的朋友希望能告诉我一下）</p>

<p><code>gulp.src</code>其实就是用<a href="https://github.com/isaacs/node-glob">node-glob</a>去读取相应文件并创建一个简单封装后的流能通过<code>pipe</code>传给后面处理</p>

<h2 id="gulp--gulp-kmd">gulp插件编写示例 ~ gulp-kmd</h2>

<p>一个简单的gulp插件需要多少行代码？我的回答是只要<strong>24</strong>行代码，对的，就是24行代码。今天在做<code>kissy editor-plugin</code>的构建的时候，用到<em>@杰少</em>写的kmd和gulp-kmc这两个工具，但是苦于没有gulp-kmd，默认的kmd模块只能在命令行下使用，不符合简化gulpfile.js的原则。于是乎看了下kmd源码提供的接口，找到<code>kmd.kissy2cmd.parse</code>这个接口就开始做一个极简单的gulp插件了，以后喜欢使用gulp的童鞋也可以免去那二十几行代码写在gulpfile.js里面了。</p>

<p><a href="https://www.npmjs.org/package/gulp-kmd">gulp-kmd传送门</a></p>

<p>代码比较少，直接贴代码了，解释写在代码注释中：</p>

<pre><code>var kmd = require('kmd'),
through2 = require('through2'),
gutil = require('gulp-util'),
PluginError = gutil.PluginError;  //官网强烈推荐标准的错误处理模块
var kissy2cmd = kmd.kissy2cmd;
const PLUGIN_NAME = 'gulp-kmd';
function confirmCmd(){
	var stream = through2.obj(function(file, enc, callback){
		//这里的file就是一个对象，有三个属性 contents（Buffer，文件内容）、base（路径）、path（路径）
		//enc指编码
		if(file.isNull()){  //如果文件为空则不处理
			return callback();
		}
		if(file.isStream()){
			this.emit('error', new PluginError(PLUGIN_NAME, 'Streams are 				not supported!'));  //规范的报错处理
  			return cb();
		}
		var fileInCmd = kissy2cmd.parse(file.contents.toString(),				{ fromString : true });
		file.contents = new Buffer(fileInCmd);
	 	this.push(file);  //把内容放到流中使得下一个任务可以处理
		callback();  //一定要调用callback告诉这个文件处理完了
	});
	return stream;
}
module.exports = confirmCmd;
</code></pre>

<p>此外，说明一下，如果直接用fs.createReadStream会是怎样呢？如下代码：</p>

<pre><code>var fs = require('fs'),
through = require('through2');
fs.createReadStream('test.txt')
	.pipe(through.obj(function(file, enc, cb){
		//这样拿到的file纯粹是一个文件的Buffer，和gulp.src拿到的不一样，也是gulp.src是对stream做了一个简单封装的表现
		debugger;
	}))
</code></pre>

<h2 id="section">总结</h2>

<p>编写一个gulp插件还是比较简单的，重要的是先要把gulp的常用几个API熟悉，以及对stream的理解，还有就是多看别人的源码和多动手debug。要获取更多的信息请移步至<a href="https://github.com/gulpjs/gulp/blob/master/docs/writing-a-plugin/README.md">gulp官网</a>看吧。</p>

  </section>
  
</article>

        </div>
        <footer>
          <div>
            
            &copy; 2014 ~ 2014  | powered by jekyll | themed by <a href="http://lhzhang.com" title="sext vi">sext vi</a> | fork <a href="https://github.com/waynezhang/blog" title="fork me">me</a>
          </div>
        </footer>
      </div> <!-- main -->
  </body>
</html>
